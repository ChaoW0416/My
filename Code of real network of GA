import numpy as np
import random
import networkx as nx
import math

# ------------------ å‚æ•°è®¾ç½® ------------------
fixed_cost = 200000
variable_cost = 50000
adjustment_coefficient = 1 / 10
max_wait_time = 15
service_rate = 1 / 30
battery_range = 200
budget = 40000000
POP_SIZE = 50
N_GENERATIONS = 100
CROSS_RATE = 0.9
MUTATION_RATE = 0.2
gamma = 0.8  # ç¢³æ’æ”¾ç³»æ•°ï¼ˆkg/kWhï¼‰
pv_unit_cost = 1200   # æ¯å¹³ç±³å…‰ä¼æ¿æŠ•èµ„æˆæœ¬ï¼ˆå…ƒ/mÂ²ï¼‰
storage_unit_cost = 1500  # å‚¨èƒ½ç³»ç»ŸæŠ•èµ„å•ä»·ï¼ˆå…ƒ/kWhï¼‰


# ------------------ ç”¨æˆ·è¾“å…¥ ------------------
NUM_NODES = int(input("è¯·è¾“å…¥èŠ‚ç‚¹æ€»æ•° NUM_NODESï¼š "))
G = nx.Graph()
G.add_nodes_from(range(NUM_NODES))

w = float(input("è¯·è¾“å…¥æƒé‡ wï¼ˆ0~1 ä¹‹é—´ï¼Œè¶Šå¤§è¶Šåå‘æµé‡ï¼Œè¶Šå°è¶Šåå‘ç¢³æ’æ”¾ï¼‰ï¼š"))
assert 0 <= w <= 1, "æƒé‡ w å¿…é¡»åœ¨ 0 å’Œ 1 ä¹‹é—´"

print("\nè¯·è¾“å…¥æ‰€æœ‰è¾¹åŠå…¶è·ç¦»ï¼ˆæ ¼å¼ï¼šèŠ‚ç‚¹i èŠ‚ç‚¹j è·ç¦»ï¼ŒèŠ‚ç‚¹ç¼–å·ä»1å¼€å§‹ï¼‰ï¼Œå¤šä¸ªè¾¹ç”¨è‹±æ–‡é€—å·åˆ†éš”")
edge_input = input("è¾“å…¥æ‰€æœ‰è¾¹ï¼š\n")
edges = [e.strip() for e in edge_input.strip().split(",")]
for e in edges:
    try:
        parts = e.split()
        i, j, d = int(parts[0]) - 1, int(parts[1]) - 1, float(parts[2])  # -1 è½¬ä¸º0-base
        assert 0 <= i < NUM_NODES and 0 <= j < NUM_NODES and i != j
        G.add_edge(i, j, weight=d)
    except Exception as ex:
        print(f"âŒ è¾¹ `{e}` è¾“å…¥æœ‰è¯¯ï¼š{ex}")


# åˆ›å»ºæƒé‡æ•°ç»„ï¼Œé»˜è®¤æ‰€æœ‰èŠ‚ç‚¹æƒé‡ä¸º 0
node_weights = np.zeros(NUM_NODES)


print("ä¾‹å¦‚ï¼š0 5, 1 8, 3 10 è¡¨ç¤ºèŠ‚ç‚¹ 0 æƒé‡ 5ï¼ŒèŠ‚ç‚¹ 1 æƒé‡ 8ï¼ŒèŠ‚ç‚¹ 3 æƒé‡ 10")
core_weights_input = input("è¯·è¾“å…¥æ ¸å¿ƒåŸå¸‚èŠ‚ç‚¹ç¼–å·å’Œå¯¹åº”æƒé‡ï¼ˆæ ¼å¼ï¼šèŠ‚ç‚¹ç¼–å· æƒé‡ï¼Œå¤šä¸ªç”¨è‹±æ–‡é€—å·åˆ†éš”ï¼ŒèŠ‚ç‚¹ç¼–å·ä»1å¼€å§‹ï¼‰ï¼š\n").strip()
try:
    for item in core_weights_input.split(","):
        node_id, weight = map(float, item.strip().split())
        node_id = int(node_id) - 1  # -1è½¬0-base
        assert 0 <= node_id < NUM_NODES, f"èŠ‚ç‚¹ç¼–å· {node_id+1} ä¸åœ¨èŒƒå›´å†…"
        node_weights[node_id] = weight
except Exception as e:
    print("âŒ è¾“å…¥æ ¼å¼æœ‰è¯¯ï¼Œè¯·æ£€æŸ¥ã€‚åº”ä¸ºï¼šèŠ‚ç‚¹ç¼–å· æƒé‡ï¼Œç”¨é€—å·åˆ†éš”ã€‚")
    raise e



eta_input = float(input("è¯·è¾“å…¥æ‰€æœ‰èŠ‚ç‚¹ç»Ÿä¸€çš„ PV è½¬æ¢æ•ˆç‡ï¼ˆ%ï¼‰ï¼š"))
eta = np.full(NUM_NODES, eta_input)
print(f"è¯·è¾“å…¥ {NUM_NODES} ä¸ªèŠ‚ç‚¹çš„å¹´å¹³å‡è¾ç…§å¼ºåº¦ï¼ˆkWh/m2ï¼‰ï¼š")
R = np.array(list(map(float, input().strip().split())))
print(f"è¯·è¾“å…¥ {NUM_NODES} ä¸ªèŠ‚ç‚¹çš„å¯éƒ¨ç½²é¢ç§¯ï¼ˆm2ï¼‰ï¼š")
A = np.array(list(map(float, input().strip().split())))
P_i = eta / 100 * R * A  # å…‰ä¼å‘ç”µé‡
min_pv_ratio = float(input("è¯·è¾“å…¥æœ€å°PVå æ¯”è¦æ±‚ï¼ˆå¦‚0.4è¡¨ç¤º40%ï¼‰ï¼š"))

core_nodes_input = input(f"è¯·è¾“å…¥æ ¸å¿ƒåŸå¸‚èŠ‚ç‚¹ç¼–å·ï¼ˆä»¥ç©ºæ ¼åˆ†éš”ï¼Œç¼–å·ä»1å¼€å§‹ï¼‰ï¼š\n").strip()
core_nodes = [int(x) - 1 for x in core_nodes_input.split()]
assert all(0 <= i < NUM_NODES for i in core_nodes), "æ ¸å¿ƒèŠ‚ç‚¹ç¼–å·å¿…é¡»åœ¨èŒƒå›´å†…"
service_nodes = [i for i in range(NUM_NODES) if i not in core_nodes]

# ------------------ å®šå®¹é˜¶æ®µ ------------------
def calculate_arrival_rates_and_capacities(G):
    arrival_rates, capacities, OD_paths, OD_flows = [], [], [], []
    for i in core_nodes:
        for j in core_nodes:
            if i == j: continue
            try:
                d = nx.shortest_path_length(G, i, j, weight='weight')
                flow = (node_weights[i] * node_weights[j])  / (d ** 1.5)
                path = nx.shortest_path(G, i, j, weight='weight')
                OD_paths.append(path)
                OD_flows.append(flow)
            except:
                continue
    for i in range(NUM_NODES):
        Î»_i = sum(flow for path, flow in zip(OD_paths, OD_flows) if i in path) * adjustment_coefficient
        arrival_rates.append(Î»_i)
        c_i = math.ceil((Î»_i * max_wait_time / 60) / service_rate)
        capacities.append(c_i)
    print("\nğŸ“Š å®šå®¹é˜¶æ®µç»“æœï¼ˆèŠ‚ç‚¹åˆ°è¾¾ç‡å’Œæ¡©æ•°ï¼‰")
    print("èŠ‚ç‚¹ç¼–å·\tåˆ°è¾¾ç‡Î»\tæ‰€éœ€æ¡©æ•°")
    for i in range(NUM_NODES):
        print(f"{i + 1:<8}\t{arrival_rates[i]:.4f}\t{capacities[i]}")  # è¾“å‡º+1
    return arrival_rates, capacities

def apply_disturbance(eta, R, A, lambda_i, avg_power, demand_noise=True, pv_noise=True):
    num_nodes = len(lambda_i)
    rng = np.random.default_rng(seed=42)  # å›ºå®šç§å­ç¡®ä¿å¯é‡å¤

    # å…‰ä¼æ‰°åŠ¨ï¼ˆÂ±5%ï¼‰
    pv_noise_factor = rng.uniform(0.80, 1.2, size=num_nodes) if pv_noise else np.ones(num_nodes)
    P_i = eta / 100 * R * A * pv_noise_factor

    # ç”µé‡éœ€æ±‚æ‰°åŠ¨ï¼ˆÂ±5%ï¼‰
    demand_noise_factor = rng.uniform(0.80, 1.20, size=num_nodes) if demand_noise else np.ones(num_nodes)
    demand_kwh = 365 * 24 * lambda_i * avg_power * demand_noise_factor

    return P_i, demand_kwh
    # ==== åŠ å…¥æ‰°åŠ¨ï¼ˆÂ±5%ï¼‰ ====
    apply_noise = input("æ˜¯å¦åŠ å…¥æ‰°åŠ¨ï¼Ÿ(y/n)ï¼š").strip().lower()
    if apply_noise == 'y':
        P_i, demand_kwh = apply_disturbance(eta, R, A, arrival_rates, avg_charge_per_vehicle, demand_noise=True, pv_noise=True)
        print("\nâš ï¸ å·²åŠ å…¥ Â±5% çš„ PV å’Œéœ€æ±‚æ‰°åŠ¨")

# ------------------ é—ä¼ ç®—æ³• ------------------

def estimate_storage_capacities(P_i, demand_kwh, days=1.0, alpha=1.1, beta=0.5):
    capacities = []
    for i in range(NUM_NODES):
        avg_pv = P_i[i] / 365
        avg_demand = demand_kwh[i] / 365
        # å‚¨èƒ½å®¹é‡ = max(Î± Ã— æ—¥PVå‘ç”µ, Î² Ã— æ—¥éœ€æ±‚) Ã— å¤©æ•°
        storage_kwh = max(alpha * avg_pv, beta * avg_demand) * days
        capacities.append(storage_kwh)
    return np.array(capacities)


def storage_cost(i, storage_capacities):
    return storage_unit_cost * storage_capacities[i]

def compute_cost(ind, capacities,storage_capacities):
    total_cost = 0
    for i, x in enumerate(ind):
        if x == 1:
            pv_cost = A[i] * pv_unit_cost
            storage = storage_cost(i,storage_capacities)
            total_cost += fixed_cost + capacities[i] * variable_cost + pv_cost + storage
    return total_cost

def compute_emission(ind, demand_kwh, P_i, gamma=0.8):
    emission = 0
    for i, x in enumerate(ind):
        if x == 1:
            grid_energy = max(demand_kwh[i] - P_i[i], 0)
            emission += grid_energy * gamma
    return emission

def compute_pv_ratio(ind, demand_kwh, P_i):
    total_demand = sum(demand_kwh[i] for i in range(NUM_NODES) if ind[i] == 1)
    total_pv = sum(min(P_i[i], demand_kwh[i]) for i in range(NUM_NODES) if ind[i] == 1)
    if total_demand == 0:
        return 0  # æ— å»ºç«™åˆ™PVå æ¯”ä¸º0
    return total_pv / total_demand


def evaluate_fitness(ind, G):
    total_flow = 0
    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i != j:
                try:
                    d = nx.shortest_path_length(G, i, j, weight='weight')
                    flow = (node_weights[i] * node_weights[j]) / (d ** 1.5)
                    if is_path_feasible(i, j, ind, G):
                        total_flow += flow
                except:
                    continue
    return total_flow

def calculate_total_flow(G):
    total = 0
    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i != j:
                try:
                    d = nx.shortest_path_length(G, i, j, weight='weight')
                    total += (node_weights[i] * node_weights[j]) / (d ** 1.5)
                except:
                    continue
    return total

def is_path_feasible(start, end, ind, G):
    try:
        path = nx.dijkstra_path(G, start, end, weight='weight')
        battery = battery_range if ind[start] else battery_range / 2
        for k in range(len(path) - 1):
            d = G[path[k]][path[k + 1]]['weight']
            battery -= d
            if battery < 0: return False
            if ind[path[k + 1]]: battery = battery_range
        return battery >= battery_range / 2 if not ind[end] else True
    except:
        return False

def evaluate_weighted_objective(total_flow, emission, total_flow_max, emission_min, emission_max, w=0.5):
    epsilon = 1e-6  # å°å€¼é¿å…é™¤é›¶

    # æµé‡å½’ä¸€åŒ–ï¼ˆè¶Šå¤§è¶Šå¥½ï¼‰
    norm_flow = total_flow / (total_flow_max + epsilon)

    # æ’æ”¾å½’ä¸€åŒ–ï¼ˆè¶Šå°è¶Šå¥½ï¼‰
    emission_range = emission_max - emission_min
    if emission_range < epsilon:
        norm_emission = 1.0  # æ²¡æœ‰æ’æ”¾å·®å¼‚ï¼Œè®¾ä¸ºæœ€ä¼˜
    else:
        norm_emission = (emission_max - emission) / emission_range

    return w * norm_flow + (1 - w) * norm_emission


def crossover(parent, pop):
    child = parent.copy()
    if np.random.rand() < CROSS_RATE:
        i_ = np.random.randint(0, POP_SIZE)
        cross_points = np.random.randint(0, 2, NUM_NODES).astype(bool)
        child[cross_points] = pop[i_][cross_points]
    return child

def mutate(child):
    for i in range(NUM_NODES):
        if np.random.rand() < MUTATION_RATE:
            child[i] = 1 - child[i]
    return child

def tournament_selection(fitnesses):
    idx1, idx2 = random.sample(range(len(fitnesses)), 2)
    return idx1 if fitnesses[idx1] > fitnesses[idx2] else idx2

def repair_individual(ind, capacities,storage_capacities):
    while compute_cost(ind, capacities,storage_capacities) > budget:
        ones = np.where(ind == 1)[0]
        if len(ones) == 0: break
        i = random.choice(ones)
        ind[i] = 0
    return ind

def run_genetic_algorithm(G, capacities, arrival_rates, P_i, demand_kwh, storage_capacities, w=0.5):
    total_flow_max = calculate_total_flow(G)
    emission_max = compute_emission(np.ones(NUM_NODES), demand_kwh, P_i)
    emission_min = 0

    population = np.random.randint(0, 2, size=(POP_SIZE, NUM_NODES))
    population = np.array([repair_individual(ind, capacities, storage_capacities) for ind in population])

    fitnesses = []
    for ind in population:
        pv_ratio = compute_pv_ratio(ind, demand_kwh, P_i)
        if pv_ratio < min_pv_ratio:
            fitnesses.append(-1e10)  # ä¸æ»¡è¶³PVå æ¯” â†’ æä½é€‚åº”åº¦
            continue
        f = evaluate_fitness(ind, G)
        e = compute_emission(ind, demand_kwh, P_i)
        fit = evaluate_weighted_objective(f, e, total_flow_max, emission_min, emission_max, w)
        fitnesses.append(fit)

    fitnesses = np.array(fitnesses)

    best_solution = population[np.argmax(fitnesses)]
    best_fitness = max(fitnesses)

    for gen in range(N_GENERATIONS):
        new_population = []
        for _ in range(POP_SIZE):
            idx = tournament_selection(fitnesses)
            parent = population[idx]
            child = crossover(parent, population)
            child = mutate(child)
            child = repair_individual(child, capacities, storage_capacities)
            new_population.append(child)

        population = np.array(new_population)
        fitnesses = []
        for ind in population:
            pv_ratio = compute_pv_ratio(ind, demand_kwh, P_i)
            if pv_ratio < min_pv_ratio:
                fitnesses.append(-1e10)
                continue
            f = evaluate_fitness(ind, G)
            e = compute_emission(ind, demand_kwh, P_i)
            fit = evaluate_weighted_objective(f, e, total_flow_max, emission_min, emission_max, w)
            fitnesses.append(fit)

        fitnesses = np.array(fitnesses)

        current_best = population[np.argmax(fitnesses)]
        if max(fitnesses) > best_fitness:
            best_solution = current_best
            best_fitness = max(fitnesses)
        population[0] = best_solution
        fitnesses[0] = best_fitness

    best_flow = evaluate_fitness(best_solution, G)
    best_emission = compute_emission(best_solution, demand_kwh, P_i)
    print("\nâœ… æœ€ä¼˜é€‰å€æ–¹æ¡ˆï¼š", (np.where(best_solution == 1)[0] + 1))
    print(f"æˆªå–æµé‡æ€»å’Œï¼š{best_flow:.2f}")
    print(f"ç¢³æ’æ”¾é‡ï¼š{best_emission:.2f} kg")
    print(f"æˆªå–å æ€»æµé‡æ¯”ä¾‹ï¼š{100 * best_flow / total_flow_max:.2f}%")
    print(f"å»ºè®¾æˆæœ¬ï¼š{compute_cost(best_solution, capacities, storage_capacities)} å…ƒ")
    print(f"PVå æ¯”ï¼š{100 * compute_pv_ratio(best_solution, demand_kwh, P_i):.2f}%")
# ------------------ ä¸»ç¨‹åº ------------------
def main():
    arrival_rates, capacities = calculate_arrival_rates_and_capacities(G)
    # ================================
    # ğŸ”‹ å¹´å……ç”µéœ€æ±‚é‡ ä¸ PV å¹´å‘ç”µé‡è®¡ç®—
    # ================================

    # è®¾ç½®å‚æ•°
    avg_charge_per_vehicle = 40  # æ¯è¾†è½¦å¹³å‡å……ç”µé‡ï¼ˆå•ä½ï¼škWhï¼‰
    HOURS_PER_YEAR = 365*24

    # å°†å°æ—¶åˆ°è¾¾ç‡è½¬æ¢ä¸ºå¹´ç”µé‡éœ€æ±‚ï¼ˆå•ä½ï¼škWhï¼‰
    demand_kwh = np.array(arrival_rates) * HOURS_PER_YEAR * avg_charge_per_vehicle
    # ç”¨æˆ·è¾“å…¥ Î± å’Œ Î²ï¼ˆPV/éœ€æ±‚è£•åº¦ç³»æ•°ï¼‰
    alpha = float(input("è¯·è¾“å…¥å…‰ä¼ä¾§å®‰å…¨ç³»æ•° Î±ï¼ˆå»ºè®® 0.1~0.5ï¼‰ï¼š"))
    beta = float(input("è¯·è¾“å…¥éœ€æ±‚ä¾§å®‰å…¨ç³»æ•° Î²ï¼ˆå»ºè®® 1.2~1.5ï¼‰ï¼š"))

    # å‚¨èƒ½å®¹é‡ä¼°ç®—
    storage_capacities = estimate_storage_capacities(P_i, demand_kwh, days=1.0, alpha=alpha, beta=beta)


    # æ‰“å°æ¯ä¸ªå»ºç«™ç‚¹çš„å¹´éœ€æ±‚ä¸PVå‘ç”µèƒ½åŠ›
    print("\nğŸ“Š æ¯ä¸ªèŠ‚ç‚¹çš„ å¹´å……ç”µéœ€æ±‚ vs å¹´PVå‘ç”µï¼ˆå•ä½ï¼škWhï¼‰")
    print("èŠ‚ç‚¹\tå¹´éœ€æ±‚\t\tPVå‘ç”µ\t\tè´­ç”µé‡")
    print("---------------------------------------------------")
    for i in range(NUM_NODES):
        demand = demand_kwh[i]
        pv = P_i[i]
        grid = max(demand - pv, 0)
        print(f"{i + 1}\t{demand:.1f}\t\t{pv:.1f}\t\t{grid:.1f}")

    run_genetic_algorithm(G, capacities, arrival_rates, P_i, demand_kwh, storage_capacities,w)


if __name__ == "__main__":
    main()
