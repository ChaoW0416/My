import numpy as np
import random
import networkx as nx
import math

# ------------------ 参数设置 ------------------
fixed_cost = 200000
variable_cost = 50000
adjustment_coefficient = 1 / 10
max_wait_time = 15
service_rate = 1 / 30
battery_range = 200
budget = 40000000
POP_SIZE = 50
N_GENERATIONS = 100
CROSS_RATE = 0.9
MUTATION_RATE = 0.2
gamma = 0.8  # 碳排放系数（kg/kWh）
pv_unit_cost = 1200   # 每平米光伏板投资成本（元/m²）
storage_unit_cost = 1500  # 储能系统投资单价（元/kWh）


# ------------------ 用户输入 ------------------
NUM_NODES = int(input("请输入节点总数 NUM_NODES： "))
G = nx.Graph()
G.add_nodes_from(range(NUM_NODES))

w = float(input("请输入权重 w（0~1 之间，越大越偏向流量，越小越偏向碳排放）："))
assert 0 <= w <= 1, "权重 w 必须在 0 和 1 之间"

print("\n请输入所有边及其距离（格式：节点i 节点j 距离，节点编号从1开始），多个边用英文逗号分隔")
edge_input = input("输入所有边：\n")
edges = [e.strip() for e in edge_input.strip().split(",")]
for e in edges:
    try:
        parts = e.split()
        i, j, d = int(parts[0]) - 1, int(parts[1]) - 1, float(parts[2])  # -1 转为0-base
        assert 0 <= i < NUM_NODES and 0 <= j < NUM_NODES and i != j
        G.add_edge(i, j, weight=d)
    except Exception as ex:
        print(f"❌ 边 `{e}` 输入有误：{ex}")


# 创建权重数组，默认所有节点权重为 0
node_weights = np.zeros(NUM_NODES)


print("例如：0 5, 1 8, 3 10 表示节点 0 权重 5，节点 1 权重 8，节点 3 权重 10")
core_weights_input = input("请输入核心城市节点编号和对应权重（格式：节点编号 权重，多个用英文逗号分隔，节点编号从1开始）：\n").strip()
try:
    for item in core_weights_input.split(","):
        node_id, weight = map(float, item.strip().split())
        node_id = int(node_id) - 1  # -1转0-base
        assert 0 <= node_id < NUM_NODES, f"节点编号 {node_id+1} 不在范围内"
        node_weights[node_id] = weight
except Exception as e:
    print("❌ 输入格式有误，请检查。应为：节点编号 权重，用逗号分隔。")
    raise e



eta_input = float(input("请输入所有节点统一的 PV 转换效率（%）："))
eta = np.full(NUM_NODES, eta_input)
print(f"请输入 {NUM_NODES} 个节点的年平均辐照强度（kWh/m2）：")
R = np.array(list(map(float, input().strip().split())))
print(f"请输入 {NUM_NODES} 个节点的可部署面积（m2）：")
A = np.array(list(map(float, input().strip().split())))
P_i = eta / 100 * R * A  # 光伏发电量
min_pv_ratio = float(input("请输入最小PV占比要求（如0.4表示40%）："))

core_nodes_input = input(f"请输入核心城市节点编号（以空格分隔，编号从1开始）：\n").strip()
core_nodes = [int(x) - 1 for x in core_nodes_input.split()]
assert all(0 <= i < NUM_NODES for i in core_nodes), "核心节点编号必须在范围内"
service_nodes = [i for i in range(NUM_NODES) if i not in core_nodes]

# ------------------ 定容阶段 ------------------
def calculate_arrival_rates_and_capacities(G):
    arrival_rates, capacities, OD_paths, OD_flows = [], [], [], []
    for i in core_nodes:
        for j in core_nodes:
            if i == j: continue
            try:
                d = nx.shortest_path_length(G, i, j, weight='weight')
                flow = (node_weights[i] * node_weights[j])  / (d ** 1.5)
                path = nx.shortest_path(G, i, j, weight='weight')
                OD_paths.append(path)
                OD_flows.append(flow)
            except:
                continue
    for i in range(NUM_NODES):
        λ_i = sum(flow for path, flow in zip(OD_paths, OD_flows) if i in path) * adjustment_coefficient
        arrival_rates.append(λ_i)
        c_i = math.ceil((λ_i * max_wait_time / 60) / service_rate)
        capacities.append(c_i)
    print("\n📊 定容阶段结果（节点到达率和桩数）")
    print("节点编号\t到达率λ\t所需桩数")
    for i in range(NUM_NODES):
        print(f"{i + 1:<8}\t{arrival_rates[i]:.4f}\t{capacities[i]}")  # 输出+1
    return arrival_rates, capacities

def apply_disturbance(eta, R, A, lambda_i, avg_power, demand_noise=True, pv_noise=True):
    num_nodes = len(lambda_i)
    rng = np.random.default_rng(seed=42)  # 固定种子确保可重复

    # 光伏扰动（±5%）
    pv_noise_factor = rng.uniform(0.80, 1.2, size=num_nodes) if pv_noise else np.ones(num_nodes)
    P_i = eta / 100 * R * A * pv_noise_factor

    # 电量需求扰动（±5%）
    demand_noise_factor = rng.uniform(0.80, 1.20, size=num_nodes) if demand_noise else np.ones(num_nodes)
    demand_kwh = 365 * 24 * lambda_i * avg_power * demand_noise_factor

    return P_i, demand_kwh
    # ==== 加入扰动（±5%） ====
    apply_noise = input("是否加入扰动？(y/n)：").strip().lower()
    if apply_noise == 'y':
        P_i, demand_kwh = apply_disturbance(eta, R, A, arrival_rates, avg_charge_per_vehicle, demand_noise=True, pv_noise=True)
        print("\n⚠️ 已加入 ±5% 的 PV 和需求扰动")

# ------------------ 遗传算法 ------------------

def estimate_storage_capacities(P_i, demand_kwh, days=1.0, alpha=1.1, beta=0.5):
    capacities = []
    for i in range(NUM_NODES):
        avg_pv = P_i[i] / 365
        avg_demand = demand_kwh[i] / 365
        # 储能容量 = max(α × 日PV发电, β × 日需求) × 天数
        storage_kwh = max(alpha * avg_pv, beta * avg_demand) * days
        capacities.append(storage_kwh)
    return np.array(capacities)


def storage_cost(i, storage_capacities):
    return storage_unit_cost * storage_capacities[i]

def compute_cost(ind, capacities,storage_capacities):
    total_cost = 0
    for i, x in enumerate(ind):
        if x == 1:
            pv_cost = A[i] * pv_unit_cost
            storage = storage_cost(i,storage_capacities)
            total_cost += fixed_cost + capacities[i] * variable_cost + pv_cost + storage
    return total_cost

def compute_emission(ind, demand_kwh, P_i, gamma=0.8):
    emission = 0
    for i, x in enumerate(ind):
        if x == 1:
            grid_energy = max(demand_kwh[i] - P_i[i], 0)
            emission += grid_energy * gamma
    return emission

def compute_pv_ratio(ind, demand_kwh, P_i):
    total_demand = sum(demand_kwh[i] for i in range(NUM_NODES) if ind[i] == 1)
    total_pv = sum(min(P_i[i], demand_kwh[i]) for i in range(NUM_NODES) if ind[i] == 1)
    if total_demand == 0:
        return 0  # 无建站则PV占比为0
    return total_pv / total_demand


def evaluate_fitness(ind, G):
    total_flow = 0
    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i != j:
                try:
                    d = nx.shortest_path_length(G, i, j, weight='weight')
                    flow = (node_weights[i] * node_weights[j]) / (d ** 1.5)
                    if is_path_feasible(i, j, ind, G):
                        total_flow += flow
                except:
                    continue
    return total_flow

def calculate_total_flow(G):
    total = 0
    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i != j:
                try:
                    d = nx.shortest_path_length(G, i, j, weight='weight')
                    total += (node_weights[i] * node_weights[j]) / (d ** 1.5)
                except:
                    continue
    return total

def is_path_feasible(start, end, ind, G):
    try:
        path = nx.dijkstra_path(G, start, end, weight='weight')
        battery = battery_range if ind[start] else battery_range / 2
        for k in range(len(path) - 1):
            d = G[path[k]][path[k + 1]]['weight']
            battery -= d
            if battery < 0: return False
            if ind[path[k + 1]]: battery = battery_range
        return battery >= battery_range / 2 if not ind[end] else True
    except:
        return False

def evaluate_weighted_objective(total_flow, emission, total_flow_max, emission_min, emission_max, w=0.5):
    epsilon = 1e-6  # 小值避免除零

    # 流量归一化（越大越好）
    norm_flow = total_flow / (total_flow_max + epsilon)

    # 排放归一化（越小越好）
    emission_range = emission_max - emission_min
    if emission_range < epsilon:
        norm_emission = 1.0  # 没有排放差异，设为最优
    else:
        norm_emission = (emission_max - emission) / emission_range

    return w * norm_flow + (1 - w) * norm_emission


def crossover(parent, pop):
    child = parent.copy()
    if np.random.rand() < CROSS_RATE:
        i_ = np.random.randint(0, POP_SIZE)
        cross_points = np.random.randint(0, 2, NUM_NODES).astype(bool)
        child[cross_points] = pop[i_][cross_points]
    return child

def mutate(child):
    for i in range(NUM_NODES):
        if np.random.rand() < MUTATION_RATE:
            child[i] = 1 - child[i]
    return child

def tournament_selection(fitnesses):
    idx1, idx2 = random.sample(range(len(fitnesses)), 2)
    return idx1 if fitnesses[idx1] > fitnesses[idx2] else idx2

def repair_individual(ind, capacities,storage_capacities):
    while compute_cost(ind, capacities,storage_capacities) > budget:
        ones = np.where(ind == 1)[0]
        if len(ones) == 0: break
        i = random.choice(ones)
        ind[i] = 0
    return ind

def run_genetic_algorithm(G, capacities, arrival_rates, P_i, demand_kwh, storage_capacities, w=0.5):
    total_flow_max = calculate_total_flow(G)
    emission_max = compute_emission(np.ones(NUM_NODES), demand_kwh, P_i)
    emission_min = 0

    population = np.random.randint(0, 2, size=(POP_SIZE, NUM_NODES))
    population = np.array([repair_individual(ind, capacities, storage_capacities) for ind in population])

    fitnesses = []
    for ind in population:
        pv_ratio = compute_pv_ratio(ind, demand_kwh, P_i)
        if pv_ratio < min_pv_ratio:
            fitnesses.append(-1e10)  # 不满足PV占比 → 极低适应度
            continue
        f = evaluate_fitness(ind, G)
        e = compute_emission(ind, demand_kwh, P_i)
        fit = evaluate_weighted_objective(f, e, total_flow_max, emission_min, emission_max, w)
        fitnesses.append(fit)

    fitnesses = np.array(fitnesses)

    best_solution = population[np.argmax(fitnesses)]
    best_fitness = max(fitnesses)

    for gen in range(N_GENERATIONS):
        new_population = []
        for _ in range(POP_SIZE):
            idx = tournament_selection(fitnesses)
            parent = population[idx]
            child = crossover(parent, population)
            child = mutate(child)
            child = repair_individual(child, capacities, storage_capacities)
            new_population.append(child)

        population = np.array(new_population)
        fitnesses = []
        for ind in population:
            pv_ratio = compute_pv_ratio(ind, demand_kwh, P_i)
            if pv_ratio < min_pv_ratio:
                fitnesses.append(-1e10)
                continue
            f = evaluate_fitness(ind, G)
            e = compute_emission(ind, demand_kwh, P_i)
            fit = evaluate_weighted_objective(f, e, total_flow_max, emission_min, emission_max, w)
            fitnesses.append(fit)

        fitnesses = np.array(fitnesses)

        current_best = population[np.argmax(fitnesses)]
        if max(fitnesses) > best_fitness:
            best_solution = current_best
            best_fitness = max(fitnesses)
        population[0] = best_solution
        fitnesses[0] = best_fitness

    best_flow = evaluate_fitness(best_solution, G)
    best_emission = compute_emission(best_solution, demand_kwh, P_i)
    print("\n✅ 最优选址方案：", (np.where(best_solution == 1)[0] + 1))
    print(f"截取流量总和：{best_flow:.2f}")
    print(f"碳排放量：{best_emission:.2f} kg")
    print(f"截取占总流量比例：{100 * best_flow / total_flow_max:.2f}%")
    print(f"建设成本：{compute_cost(best_solution, capacities, storage_capacities)} 元")
    print(f"PV占比：{100 * compute_pv_ratio(best_solution, demand_kwh, P_i):.2f}%")
# ------------------ 主程序 ------------------
def main():
    arrival_rates, capacities = calculate_arrival_rates_and_capacities(G)
    # ================================
    # 🔋 年充电需求量 与 PV 年发电量计算
    # ================================

    # 设置参数
    avg_charge_per_vehicle = 40  # 每辆车平均充电量（单位：kWh）
    HOURS_PER_YEAR = 365*24

    # 将小时到达率转换为年电量需求（单位：kWh）
    demand_kwh = np.array(arrival_rates) * HOURS_PER_YEAR * avg_charge_per_vehicle
    # 用户输入 α 和 β（PV/需求裕度系数）
    alpha = float(input("请输入光伏侧安全系数 α（建议 0.1~0.5）："))
    beta = float(input("请输入需求侧安全系数 β（建议 1.2~1.5）："))

    # 储能容量估算
    storage_capacities = estimate_storage_capacities(P_i, demand_kwh, days=1.0, alpha=alpha, beta=beta)


    # 打印每个建站点的年需求与PV发电能力
    print("\n📊 每个节点的 年充电需求 vs 年PV发电（单位：kWh）")
    print("节点\t年需求\t\tPV发电\t\t购电量")
    print("---------------------------------------------------")
    for i in range(NUM_NODES):
        demand = demand_kwh[i]
        pv = P_i[i]
        grid = max(demand - pv, 0)
        print(f"{i + 1}\t{demand:.1f}\t\t{pv:.1f}\t\t{grid:.1f}")

    run_genetic_algorithm(G, capacities, arrival_rates, P_i, demand_kwh, storage_capacities,w)


if __name__ == "__main__":
    main()
