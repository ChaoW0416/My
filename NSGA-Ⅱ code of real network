import numpy as np
import random
import networkx as nx
import math

from pymoo.core.sampling import Sampling
from pymoo.core.problem import Problem
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.termination import get_termination
from pymoo.optimize import minimize
from pymoo.operators.sampling.rnd import BinaryRandomSampling
from pymoo.operators.crossover.hux import HUX
from pymoo.operators.mutation.bitflip import BitflipMutation
import matplotlib.pyplot as plt

# ------------------ å‚æ•°è®¾ç½® ------------------
fixed_cost = 200000
variable_cost = 50000
adjustment_coefficient = 1 / 10
max_wait_time = 15
service_rate = 1 / 30
battery_range = 200
budget = 40000000
gamma = 0.8  # ç¢³æ’æ”¾ç³»æ•°ï¼ˆkg/kWhï¼‰
pv_unit_cost = 1200   # æ¯å¹³ç±³å…‰ä¼æ¿æŠ•èµ„æˆæœ¬ï¼ˆå…ƒ/mÂ²ï¼‰
storage_unit_cost = 1500  # å‚¨èƒ½ç³»ç»ŸæŠ•èµ„å•ä»·ï¼ˆå…ƒ/kWhï¼‰

POP_SIZE = 100
N_GENERATIONS = 200

# ------------------ ç”¨æˆ·è¾“å…¥ ------------------
NUM_NODES = int(input("è¯·è¾“å…¥èŠ‚ç‚¹æ€»æ•° NUM_NODESï¼š "))
G = nx.Graph()
G.add_nodes_from(range(NUM_NODES))

print("\nè¯·è¾“å…¥æ‰€æœ‰è¾¹åŠå…¶è·ç¦»ï¼ˆæ ¼å¼ï¼šèŠ‚ç‚¹i èŠ‚ç‚¹j è·ç¦»ï¼ŒèŠ‚ç‚¹ç¼–å·ä»1å¼€å§‹ï¼‰ï¼Œå¤šä¸ªè¾¹ç”¨è‹±æ–‡é€—å·åˆ†éš”")
edge_input = input("è¾“å…¥æ‰€æœ‰è¾¹ï¼š\n")
edges = [e.strip() for e in edge_input.strip().split(",")]
for e in edges:
    try:
        parts = e.split()
        i, j, d = int(parts[0]) - 1, int(parts[1]) - 1, float(parts[2])  # -1 è½¬ä¸º0-base
        assert 0 <= i < NUM_NODES and 0 <= j < NUM_NODES and i != j
        G.add_edge(i, j, weight=d)
    except Exception as ex:
        print(f"âŒ è¾¹ `{e}` è¾“å…¥æœ‰è¯¯ï¼š{ex}")

# åˆ›å»ºæƒé‡æ•°ç»„ï¼Œé»˜è®¤æ‰€æœ‰èŠ‚ç‚¹æƒé‡ä¸º 0
node_weights = np.zeros(NUM_NODES)


print("ä¾‹å¦‚ï¼š0 5, 1 8, 3 10 è¡¨ç¤ºèŠ‚ç‚¹ 0 æƒé‡ 5ï¼ŒèŠ‚ç‚¹ 1 æƒé‡ 8ï¼ŒèŠ‚ç‚¹ 3 æƒé‡ 10")
core_weights_input = input("è¯·è¾“å…¥æ ¸å¿ƒåŸå¸‚èŠ‚ç‚¹ç¼–å·å’Œå¯¹åº”æƒé‡ï¼ˆæ ¼å¼ï¼šèŠ‚ç‚¹ç¼–å· æƒé‡ï¼Œå¤šä¸ªç”¨è‹±æ–‡é€—å·åˆ†éš”ï¼ŒèŠ‚ç‚¹ç¼–å·ä»1å¼€å§‹ï¼‰ï¼š\n").strip()
try:
    for item in core_weights_input.split(","):
        node_id, weight = map(float, item.strip().split())
        node_id = int(node_id) - 1  # -1è½¬0-base
        assert 0 <= node_id < NUM_NODES, f"èŠ‚ç‚¹ç¼–å· {node_id+1} ä¸åœ¨èŒƒå›´å†…"
        node_weights[node_id] = weight
except Exception as e:
    print("âŒ è¾“å…¥æ ¼å¼æœ‰è¯¯ï¼Œè¯·æ£€æŸ¥ã€‚åº”ä¸ºï¼šèŠ‚ç‚¹ç¼–å· æƒé‡ï¼Œç”¨é€—å·åˆ†éš”ã€‚")
    raise e

eta_input = float(input("è¯·è¾“å…¥æ‰€æœ‰èŠ‚ç‚¹ç»Ÿä¸€çš„ PV è½¬æ¢æ•ˆç‡ï¼ˆ%ï¼‰ï¼š"))
eta = np.full(NUM_NODES, eta_input)
print(f"è¯·è¾“å…¥ {NUM_NODES} ä¸ªèŠ‚ç‚¹çš„å¹´å¹³å‡è¾ç…§å¼ºåº¦ï¼ˆkWh/m2ï¼‰ï¼š")
R = np.array(list(map(float, input().strip().split())))
print(f"è¯·è¾“å…¥ {NUM_NODES} ä¸ªèŠ‚ç‚¹çš„å¯éƒ¨ç½²é¢ç§¯ï¼ˆm2ï¼‰ï¼š")
A = np.array(list(map(float, input().strip().split())))

P_i = eta / 100 * R * A  # å…‰ä¼å‘ç”µé‡
min_pv_ratio = float(input("è¯·è¾“å…¥æœ€å°PVå æ¯”è¦æ±‚ï¼ˆå¦‚0.4è¡¨ç¤º40%ï¼‰ï¼š"))

core_nodes_input = input(f"è¯·è¾“å…¥æ ¸å¿ƒåŸå¸‚èŠ‚ç‚¹ç¼–å·ï¼ˆä»¥ç©ºæ ¼åˆ†éš”ï¼Œç¼–å·ä»1å¼€å§‹ï¼‰ï¼š\n").strip()
core_nodes = [int(x) - 1 for x in core_nodes_input.split()]
assert all(0 <= i < NUM_NODES for i in core_nodes), "æ ¸å¿ƒèŠ‚ç‚¹ç¼–å·å¿…é¡»åœ¨èŒƒå›´å†…"
service_nodes = [i for i in range(NUM_NODES) if i not in core_nodes]

from pymoo.util.misc import stack

def eliminate_duplicates(pop):
    unique_objs = np.unique(stack(pop.get("F")), axis=0)
    unique_indices = [i for i, f in enumerate(pop.get("F")) if any((f == u).all() for u in unique_objs)]
    return pop[unique_indices]

from pymoo.core.sampling import Sampling

class MixedBinarySampling(Sampling):
    def __init__(self, sparse_ratio=0.5):
        super().__init__()
        self.sparse_ratio = sparse_ratio

    def _do(self, problem, n_samples, **kwargs):
        n_var = problem.n_var
        X = np.zeros((n_samples, n_var), dtype=np.bool_)

        num_sparse = int(n_samples * self.sparse_ratio)

        for i in range(n_samples):
            if i < num_sparse:
                n_active = np.random.randint(2, 6)
            else:
                max_active = min(n_var, 20)
                n_active = np.random.randint(10, max_active + 1)

            selected = np.random.choice(n_var, size=n_active, replace=False)
            X[i, selected] = True

        return X

# ------------------ å®šå®¹é˜¶æ®µ ------------------
def calculate_arrival_rates_and_capacities(G):
    arrival_rates, capacities, OD_paths, OD_flows = [], [], [], []
    for i in core_nodes:
        for j in core_nodes:
            if i == j: continue
            try:
                d = nx.shortest_path_length(G, i, j, weight='weight')
                flow = (node_weights[i] * node_weights[j])  / (d ** 1.5)
                path = nx.shortest_path(G, i, j, weight='weight')
                OD_paths.append(path)
                OD_flows.append(flow)
            except:
                continue
    for i in range(NUM_NODES):
        Î»_i = sum(flow for path, flow in zip(OD_paths, OD_flows) if i in path) * adjustment_coefficient
        arrival_rates.append(Î»_i)
        c_i = math.ceil((Î»_i * max_wait_time / 60) / service_rate)
        capacities.append(c_i)
    print("\nğŸ“Š å®šå®¹é˜¶æ®µç»“æœï¼ˆèŠ‚ç‚¹åˆ°è¾¾ç‡å’Œæ¡©æ•°ï¼‰")
    print("èŠ‚ç‚¹ç¼–å·\tåˆ°è¾¾ç‡Î»\tæ‰€éœ€æ¡©æ•°")
    for i in range(NUM_NODES):
        print(f"{i + 1:<8}\t{arrival_rates[i]:.4f}\t{capacities[i]}")  # è¾“å‡º+1
    return np.array(arrival_rates), np.array(capacities)


def estimate_storage_capacities(P_i, demand_kwh, days=1.0, alpha=1.1, beta=0.5):
    capacities = []
    for i in range(NUM_NODES):
        avg_pv = P_i[i] / 365
        avg_demand = demand_kwh[i] / 365
        # å‚¨èƒ½å®¹é‡ = max(Î± Ã— æ—¥PVå‘ç”µ, Î² Ã— æ—¥éœ€æ±‚) Ã— å¤©æ•°
        storage_kwh = max(alpha * avg_pv, beta * avg_demand) * days
        capacities.append(storage_kwh)
    return np.array(capacities)

def storage_cost(i, storage_capacities):
    return storage_unit_cost * storage_capacities[i]

def compute_cost(ind, capacities,storage_capacities):
    total_cost = 0
    for i, x in enumerate(ind):
        if x == 1:
            pv_cost = A[i] * pv_unit_cost
            storage = storage_cost(i,storage_capacities)
            total_cost += fixed_cost + capacities[i] * variable_cost + pv_cost + storage
    return total_cost

def compute_emission(ind, demand_kwh, P_i, gamma=0.8):
    emission = 0
    for i, x in enumerate(ind):
        if x == 1:
            grid_energy = max(demand_kwh[i] - P_i[i], 0)
            emission += grid_energy * gamma
    return emission

def compute_pv_ratio(ind, demand_kwh, P_i):
    total_demand = sum(demand_kwh[i] for i in range(NUM_NODES) if ind[i] == 1)
    total_pv = sum(min(P_i[i], demand_kwh[i]) for i in range(NUM_NODES) if ind[i] == 1)
    if total_demand == 0:
        return 0  # æ— å»ºç«™åˆ™PVå æ¯”ä¸º0
    return total_pv / total_demand

def evaluate_fitness(ind, G):
    total_flow = 0
    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i != j:
                try:
                    d = nx.shortest_path_length(G, i, j, weight='weight')
                    flow = (node_weights[i] * node_weights[j]) / (d ** 1.5)
                    if is_path_feasible(i, j, ind, G):
                        total_flow += flow
                except:
                    continue
    return total_flow

def calculate_total_flow(G):
    total = 0
    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i != j:
                try:
                    d = nx.shortest_path_length(G, i, j, weight='weight')
                    total += (node_weights[i] * node_weights[j]) / (d ** 1.5)
                except:
                    continue
    return total

def is_path_feasible(start, end, ind, G):
    try:
        path = nx.dijkstra_path(G, start, end, weight='weight')
        battery = battery_range if ind[start] else battery_range / 2
        for k in range(len(path) - 1):
            d = G[path[k]][path[k + 1]]['weight']
            battery -= d
            if battery < 0: return False
            if ind[path[k + 1]]: battery = battery_range
        return battery >= battery_range / 2 if not ind[end] else True
    except:
        return False

def apply_disturbance(eta, R, A, lambda_i, avg_power, demand_noise=True, pv_noise=True):
    rng = np.random.default_rng(seed=42)  # å›ºå®šç§å­ä¿è¯å¤ç°æ€§
    num_nodes = len(lambda_i)

    # å…‰ä¼æ‰°åŠ¨ï¼ˆÂ±20%ï¼‰
    pv_noise_factor = rng.uniform(0.80,1.2,size=num_nodes) if pv_noise else np.ones(num_nodes)
    disturbed_P_i = eta / 100 * R * A * pv_noise_factor

    # ç”µé‡éœ€æ±‚æ‰°åŠ¨ï¼ˆÂ±20%ï¼‰
    demand_noise_factor = rng.uniform(0.80, 1.20, size=num_nodes) if demand_noise else np.ones(num_nodes)
    disturbed_demand_kwh = 365 * 24 * lambda_i * avg_power * demand_noise_factor

    return disturbed_P_i, disturbed_demand_kwh



# ------------------ NSGA-II é—®é¢˜å®šä¹‰ ------------------
class ChargingStationProblem(Problem):
    def __init__(self, G, capacities, P_i, demand_kwh, storage_capacities, min_pv_ratio, budget):
        super().__init__(n_var=NUM_NODES, n_obj=2, n_constr=2, xl=0, xu=1, type_var=np.bool_)
        self.G = G
        self.capacities = capacities
        self.P_i = P_i
        self.demand_kwh = demand_kwh
        self.storage_capacities = storage_capacities
        self.min_pv_ratio = min_pv_ratio
        self.budget = budget



    def _evaluate(self, X, out, *args, **kwargs):
        flows = []
        emissions = []
        costs = []
        pv_ratio_violations = []
        for ind in X:
            f = evaluate_fitness(ind, self.G)
            e = compute_emission(ind, self.demand_kwh, self.P_i)
            c = compute_cost(ind, self.capacities, self.storage_capacities)
            pv_energy = sum(min(self.P_i[i], self.demand_kwh[i]) for i in range(NUM_NODES) if ind[i] == 1)
            total_demand = sum(self.demand_kwh[i] for i in range(NUM_NODES) if ind[i] == 1)
            ratio = pv_energy / total_demand if total_demand > 0 else 0
            pv_ratio_violations.append(ratio - self.min_pv_ratio)
            flows.append(-f)
            emissions.append(e)
            costs.append(c)

        out["F"] = np.column_stack([flows, emissions])
        out["G"] = np.column_stack([
            [self.budget - c for c in costs],
            pv_ratio_violations
        ])

# ------------------ ä¸»ç¨‹åº ------------------
def run_nsga2(G, capacities, P_i, demand_kwh, min_pv_ratio):

    alpha = float(input("è¯·è¾“å…¥å…‰ä¼ä¾§å®‰å…¨ç³»æ•° Î±ï¼ˆå»ºè®® 0.1~0.5ï¼‰ï¼š"))
    beta = float(input("è¯·è¾“å…¥éœ€æ±‚ä¾§å®‰å…¨ç³»æ•° Î²ï¼ˆå»ºè®® 1.2~1.5ï¼‰ï¼š"))
    storage_capacities = estimate_storage_capacities(P_i, demand_kwh, alpha=alpha, beta=beta)

    problem = ChargingStationProblem(G, capacities, P_i, demand_kwh, storage_capacities, min_pv_ratio,budget)

    algorithm = NSGA2(
        pop_size=POP_SIZE,
        sampling=MixedBinarySampling(),  # ğŸ”„ ä½¿ç”¨è‡ªå®šä¹‰æ··åˆé‡‡æ ·
        crossover=HUX(prob=0.9),
        mutation=BitflipMutation(prob=0.2),
        eliminate_duplicates=True
    )

    termination = get_termination("n_gen", N_GENERATIONS)

    res = minimize(
        problem,
        algorithm,
        termination,
        seed=1,
        save_history=True,
        verbose=True
    )

    # æ‰“å°éåŠ£è§£
    print("\nâœ… éåŠ£è§£é›†ï¼š")
    total_flow = calculate_total_flow(G)
    for i, ind in enumerate(res.X):
        flow = -res.F[i][0]
        emission = res.F[i][1]
        ratio = flow / total_flow if total_flow > 0 else 0
        print(
            f"æ–¹æ¡ˆ{i + 1}: å»ºè®¾èŠ‚ç‚¹ {np.where(ind == 1)[0]} | æµé‡={flow:.2f} | å æ¯”={ratio:.2%} | æ’æ”¾={emission:.2f}kg")

    # å¯è§†åŒ–å¸•ç´¯æ‰˜å‰æ²¿
    plt.scatter(-res.F[:, 0], res.F[:, 1], c='blue')
    plt.xlabel("Captured flows")
    plt.ylabel("Carbon Emission (kg)")
    plt.title("NSGA-II optimization result (Pareto frontier)")
    plt.grid(True)
    plt.gca().invert_yaxis()
    plt.show()

# ------------------ å¯åŠ¨å…¥å£ ------------------
def main():
    arrival_rates, capacities = calculate_arrival_rates_and_capacities(G)
    avg_charge_per_vehicle = 40
    HOURS_PER_YEAR = 365 * 24
    demand_kwh = np.array(arrival_rates) * HOURS_PER_YEAR * avg_charge_per_vehicle
    disturbed_P_i, disturbed_demand_kwh = apply_disturbance(
        eta, R, A, arrival_rates, avg_charge_per_vehicle,
        demand_noise=True, pv_noise=True
    )
    run_nsga2(G, capacities, disturbed_P_i, disturbed_demand_kwh, min_pv_ratio)


if __name__ == "__main__":
    main()
