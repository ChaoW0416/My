import numpy as np
import random
import networkx as nx
import math

from pymoo.core.sampling import Sampling
from pymoo.core.problem import Problem
from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.termination import get_termination
from pymoo.optimize import minimize
from pymoo.operators.sampling.rnd import BinaryRandomSampling
from pymoo.operators.crossover.hux import HUX
from pymoo.operators.mutation.bitflip import BitflipMutation
import matplotlib.pyplot as plt

# ------------------ 参数设置 ------------------
fixed_cost = 200000
variable_cost = 50000
adjustment_coefficient = 1 / 10
max_wait_time = 15
service_rate = 1 / 30
battery_range = 200
budget = 40000000
gamma = 0.8  # 碳排放系数（kg/kWh）
pv_unit_cost = 1200   # 每平米光伏板投资成本（元/m²）
storage_unit_cost = 1500  # 储能系统投资单价（元/kWh）

POP_SIZE = 100
N_GENERATIONS = 200

# ------------------ 用户输入 ------------------
NUM_NODES = int(input("请输入节点总数 NUM_NODES： "))
G = nx.Graph()
G.add_nodes_from(range(NUM_NODES))

print("\n请输入所有边及其距离（格式：节点i 节点j 距离，节点编号从1开始），多个边用英文逗号分隔")
edge_input = input("输入所有边：\n")
edges = [e.strip() for e in edge_input.strip().split(",")]
for e in edges:
    try:
        parts = e.split()
        i, j, d = int(parts[0]) - 1, int(parts[1]) - 1, float(parts[2])  # -1 转为0-base
        assert 0 <= i < NUM_NODES and 0 <= j < NUM_NODES and i != j
        G.add_edge(i, j, weight=d)
    except Exception as ex:
        print(f"❌ 边 `{e}` 输入有误：{ex}")

# 创建权重数组，默认所有节点权重为 0
node_weights = np.zeros(NUM_NODES)


print("例如：0 5, 1 8, 3 10 表示节点 0 权重 5，节点 1 权重 8，节点 3 权重 10")
core_weights_input = input("请输入核心城市节点编号和对应权重（格式：节点编号 权重，多个用英文逗号分隔，节点编号从1开始）：\n").strip()
try:
    for item in core_weights_input.split(","):
        node_id, weight = map(float, item.strip().split())
        node_id = int(node_id) - 1  # -1转0-base
        assert 0 <= node_id < NUM_NODES, f"节点编号 {node_id+1} 不在范围内"
        node_weights[node_id] = weight
except Exception as e:
    print("❌ 输入格式有误，请检查。应为：节点编号 权重，用逗号分隔。")
    raise e

eta_input = float(input("请输入所有节点统一的 PV 转换效率（%）："))
eta = np.full(NUM_NODES, eta_input)
print(f"请输入 {NUM_NODES} 个节点的年平均辐照强度（kWh/m2）：")
R = np.array(list(map(float, input().strip().split())))
print(f"请输入 {NUM_NODES} 个节点的可部署面积（m2）：")
A = np.array(list(map(float, input().strip().split())))

P_i = eta / 100 * R * A  # 光伏发电量
min_pv_ratio = float(input("请输入最小PV占比要求（如0.4表示40%）："))

core_nodes_input = input(f"请输入核心城市节点编号（以空格分隔，编号从1开始）：\n").strip()
core_nodes = [int(x) - 1 for x in core_nodes_input.split()]
assert all(0 <= i < NUM_NODES for i in core_nodes), "核心节点编号必须在范围内"
service_nodes = [i for i in range(NUM_NODES) if i not in core_nodes]

from pymoo.util.misc import stack

def eliminate_duplicates(pop):
    unique_objs = np.unique(stack(pop.get("F")), axis=0)
    unique_indices = [i for i, f in enumerate(pop.get("F")) if any((f == u).all() for u in unique_objs)]
    return pop[unique_indices]

from pymoo.core.sampling import Sampling

class MixedBinarySampling(Sampling):
    def __init__(self, sparse_ratio=0.5):
        super().__init__()
        self.sparse_ratio = sparse_ratio

    def _do(self, problem, n_samples, **kwargs):
        n_var = problem.n_var
        X = np.zeros((n_samples, n_var), dtype=np.bool_)

        num_sparse = int(n_samples * self.sparse_ratio)

        for i in range(n_samples):
            if i < num_sparse:
                n_active = np.random.randint(2, 6)
            else:
                max_active = min(n_var, 20)
                n_active = np.random.randint(10, max_active + 1)

            selected = np.random.choice(n_var, size=n_active, replace=False)
            X[i, selected] = True

        return X

# ------------------ 定容阶段 ------------------
def calculate_arrival_rates_and_capacities(G):
    arrival_rates, capacities, OD_paths, OD_flows = [], [], [], []
    for i in core_nodes:
        for j in core_nodes:
            if i == j: continue
            try:
                d = nx.shortest_path_length(G, i, j, weight='weight')
                flow = (node_weights[i] * node_weights[j])  / (d ** 1.5)
                path = nx.shortest_path(G, i, j, weight='weight')
                OD_paths.append(path)
                OD_flows.append(flow)
            except:
                continue
    for i in range(NUM_NODES):
        λ_i = sum(flow for path, flow in zip(OD_paths, OD_flows) if i in path) * adjustment_coefficient
        arrival_rates.append(λ_i)
        c_i = math.ceil((λ_i * max_wait_time / 60) / service_rate)
        capacities.append(c_i)
    print("\n📊 定容阶段结果（节点到达率和桩数）")
    print("节点编号\t到达率λ\t所需桩数")
    for i in range(NUM_NODES):
        print(f"{i + 1:<8}\t{arrival_rates[i]:.4f}\t{capacities[i]}")  # 输出+1
    return np.array(arrival_rates), np.array(capacities)


def estimate_storage_capacities(P_i, demand_kwh, days=1.0, alpha=1.1, beta=0.5):
    capacities = []
    for i in range(NUM_NODES):
        avg_pv = P_i[i] / 365
        avg_demand = demand_kwh[i] / 365
        # 储能容量 = max(α × 日PV发电, β × 日需求) × 天数
        storage_kwh = max(alpha * avg_pv, beta * avg_demand) * days
        capacities.append(storage_kwh)
    return np.array(capacities)

def storage_cost(i, storage_capacities):
    return storage_unit_cost * storage_capacities[i]

def compute_cost(ind, capacities,storage_capacities):
    total_cost = 0
    for i, x in enumerate(ind):
        if x == 1:
            pv_cost = A[i] * pv_unit_cost
            storage = storage_cost(i,storage_capacities)
            total_cost += fixed_cost + capacities[i] * variable_cost + pv_cost + storage
    return total_cost

def compute_emission(ind, demand_kwh, P_i, gamma=0.8):
    emission = 0
    for i, x in enumerate(ind):
        if x == 1:
            grid_energy = max(demand_kwh[i] - P_i[i], 0)
            emission += grid_energy * gamma
    return emission

def compute_pv_ratio(ind, demand_kwh, P_i):
    total_demand = sum(demand_kwh[i] for i in range(NUM_NODES) if ind[i] == 1)
    total_pv = sum(min(P_i[i], demand_kwh[i]) for i in range(NUM_NODES) if ind[i] == 1)
    if total_demand == 0:
        return 0  # 无建站则PV占比为0
    return total_pv / total_demand

def evaluate_fitness(ind, G):
    total_flow = 0
    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i != j:
                try:
                    d = nx.shortest_path_length(G, i, j, weight='weight')
                    flow = (node_weights[i] * node_weights[j]) / (d ** 1.5)
                    if is_path_feasible(i, j, ind, G):
                        total_flow += flow
                except:
                    continue
    return total_flow

def calculate_total_flow(G):
    total = 0
    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i != j:
                try:
                    d = nx.shortest_path_length(G, i, j, weight='weight')
                    total += (node_weights[i] * node_weights[j]) / (d ** 1.5)
                except:
                    continue
    return total

def is_path_feasible(start, end, ind, G):
    try:
        path = nx.dijkstra_path(G, start, end, weight='weight')
        battery = battery_range if ind[start] else battery_range / 2
        for k in range(len(path) - 1):
            d = G[path[k]][path[k + 1]]['weight']
            battery -= d
            if battery < 0: return False
            if ind[path[k + 1]]: battery = battery_range
        return battery >= battery_range / 2 if not ind[end] else True
    except:
        return False

def apply_disturbance(eta, R, A, lambda_i, avg_power, demand_noise=True, pv_noise=True):
    rng = np.random.default_rng(seed=42)  # 固定种子保证复现性
    num_nodes = len(lambda_i)

    # 光伏扰动（±20%）
    pv_noise_factor = rng.uniform(0.80,1.2,size=num_nodes) if pv_noise else np.ones(num_nodes)
    disturbed_P_i = eta / 100 * R * A * pv_noise_factor

    # 电量需求扰动（±20%）
    demand_noise_factor = rng.uniform(0.80, 1.20, size=num_nodes) if demand_noise else np.ones(num_nodes)
    disturbed_demand_kwh = 365 * 24 * lambda_i * avg_power * demand_noise_factor

    return disturbed_P_i, disturbed_demand_kwh



# ------------------ NSGA-II 问题定义 ------------------
class ChargingStationProblem(Problem):
    def __init__(self, G, capacities, P_i, demand_kwh, storage_capacities, min_pv_ratio, budget):
        super().__init__(n_var=NUM_NODES, n_obj=2, n_constr=2, xl=0, xu=1, type_var=np.bool_)
        self.G = G
        self.capacities = capacities
        self.P_i = P_i
        self.demand_kwh = demand_kwh
        self.storage_capacities = storage_capacities
        self.min_pv_ratio = min_pv_ratio
        self.budget = budget



    def _evaluate(self, X, out, *args, **kwargs):
        flows = []
        emissions = []
        costs = []
        pv_ratio_violations = []
        for ind in X:
            f = evaluate_fitness(ind, self.G)
            e = compute_emission(ind, self.demand_kwh, self.P_i)
            c = compute_cost(ind, self.capacities, self.storage_capacities)
            pv_energy = sum(min(self.P_i[i], self.demand_kwh[i]) for i in range(NUM_NODES) if ind[i] == 1)
            total_demand = sum(self.demand_kwh[i] for i in range(NUM_NODES) if ind[i] == 1)
            ratio = pv_energy / total_demand if total_demand > 0 else 0
            pv_ratio_violations.append(ratio - self.min_pv_ratio)
            flows.append(-f)
            emissions.append(e)
            costs.append(c)

        out["F"] = np.column_stack([flows, emissions])
        out["G"] = np.column_stack([
            [self.budget - c for c in costs],
            pv_ratio_violations
        ])

# ------------------ 主程序 ------------------
def run_nsga2(G, capacities, P_i, demand_kwh, min_pv_ratio):

    alpha = float(input("请输入光伏侧安全系数 α（建议 0.1~0.5）："))
    beta = float(input("请输入需求侧安全系数 β（建议 1.2~1.5）："))
    storage_capacities = estimate_storage_capacities(P_i, demand_kwh, alpha=alpha, beta=beta)

    problem = ChargingStationProblem(G, capacities, P_i, demand_kwh, storage_capacities, min_pv_ratio,budget)

    algorithm = NSGA2(
        pop_size=POP_SIZE,
        sampling=MixedBinarySampling(),  # 🔄 使用自定义混合采样
        crossover=HUX(prob=0.9),
        mutation=BitflipMutation(prob=0.2),
        eliminate_duplicates=True
    )

    termination = get_termination("n_gen", N_GENERATIONS)

    res = minimize(
        problem,
        algorithm,
        termination,
        seed=1,
        save_history=True,
        verbose=True
    )

    # 打印非劣解
    print("\n✅ 非劣解集：")
    total_flow = calculate_total_flow(G)
    for i, ind in enumerate(res.X):
        flow = -res.F[i][0]
        emission = res.F[i][1]
        ratio = flow / total_flow if total_flow > 0 else 0
        print(
            f"方案{i + 1}: 建设节点 {np.where(ind == 1)[0]} | 流量={flow:.2f} | 占比={ratio:.2%} | 排放={emission:.2f}kg")

    # 可视化帕累托前沿
    plt.scatter(-res.F[:, 0], res.F[:, 1], c='blue')
    plt.xlabel("Captured flows")
    plt.ylabel("Carbon Emission (kg)")
    plt.title("NSGA-II optimization result (Pareto frontier)")
    plt.grid(True)
    plt.gca().invert_yaxis()
    plt.show()

# ------------------ 启动入口 ------------------
def main():
    arrival_rates, capacities = calculate_arrival_rates_and_capacities(G)
    avg_charge_per_vehicle = 40
    HOURS_PER_YEAR = 365 * 24
    demand_kwh = np.array(arrival_rates) * HOURS_PER_YEAR * avg_charge_per_vehicle
    disturbed_P_i, disturbed_demand_kwh = apply_disturbance(
        eta, R, A, arrival_rates, avg_charge_per_vehicle,
        demand_noise=True, pv_noise=True
    )
    run_nsga2(G, capacities, disturbed_P_i, disturbed_demand_kwh, min_pv_ratio)


if __name__ == "__main__":
    main()
