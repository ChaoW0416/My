import numpy as np
import random
import networkx as nx

fixed_cost = 200000          # æ‰€æœ‰ç«™ç‚¹ç»Ÿä¸€å›ºå®šæˆæœ¬
variable_cost = 50000       # æ‰€æœ‰ç«™ç‚¹ç»Ÿä¸€æ¯æ¡©æˆæœ¬
adjustment_coefficient = 1/10000000
max_wait_time = 20         # å•ä½ï¼šåˆ†é’Ÿ
service_rate = 1/30           #
battery_range = 9         # ç”µåŠ¨è½¦ç»­èˆª
budget = 7000000             # æ€»é¢„ç®—


NUM_NODES = int(input("è¯·è¾“å…¥èŠ‚ç‚¹æ€»æ•° NUM_NODESï¼š "))
G = nx.Graph()
G.add_nodes_from(range(NUM_NODES))  # åŠ å…¥èŠ‚ç‚¹0~N-1

print(f"\nè¯·è¾“å…¥æ‰€æœ‰è¾¹åŠå…¶è·ç¦»ï¼ˆæ ¼å¼ï¼šèŠ‚ç‚¹i èŠ‚ç‚¹j è·ç¦»ï¼‰ï¼Œå¤šä¸ªè¾¹ç”¨è‹±æ–‡é€—å·åˆ†éš”")
print("ä¾‹å¦‚ï¼š0 1 12.5, 0 2 18, 1 3 9.2")

edge_input = input("è¾“å…¥æ‰€æœ‰è¾¹ï¼š\n")

edges = [e.strip() for e in edge_input.strip().split(",")]

for e in edges:
    try:
        parts = e.split()
        if len(parts) != 3:
            raise ValueError("æ¯æ¡è¾¹æ ¼å¼åº”ä¸º i j è·ç¦»")
        i, j = int(parts[0]), int(parts[1])
        d = float(parts[2])
        if not (0 <= i <= NUM_NODES and 0 <= j <= NUM_NODES):
            raise ValueError(f"èŠ‚ç‚¹ç¼–å·åº”åœ¨ 0 ~ {NUM_NODES} ä¹‹é—´")
        if i == j:
            raise ValueError("ä¸èƒ½è¾“å…¥è‡ªç¯è¾¹")
        G.add_edge(i, j, weight=d)
        print(f"âœ… æ·»åŠ è¾¹ï¼š{i} -- {j}ï¼Œè·ç¦» = {d}")
    except Exception as ex:
        print(f"âŒ è¾¹ `{e}` è¾“å…¥æœ‰è¯¯ï¼š{ex}")

    # ç”¨æˆ·è‡ªå®šä¹‰å‚æ•°
    # æ‰‹åŠ¨è¾“å…¥æ¯ä¸ªèŠ‚ç‚¹çš„æƒé‡
print(f"è¯·è¾“å…¥ {NUM_NODES} ä¸ªèŠ‚ç‚¹çš„æƒé‡ï¼ˆç©ºæ ¼åˆ†éš”ï¼‰:")
user_input = input()
node_weights = np.array(list(map(float, user_input.strip().split())))

# æ£€æŸ¥æ•°é‡æ˜¯å¦æ­£ç¡®
assert len(node_weights) == NUM_NODES, "èŠ‚ç‚¹æƒé‡æ•°é‡ä¸èŠ‚ç‚¹æ•°ä¸åŒ¹é…ï¼"

POP_SIZE = 30
DNA_SIZE = NUM_NODES
N_GENERATIONS = 100
CROSS_RATE = 0.9
MUTATION_RATE = 0.1

def calculate_arrival_rates_and_capacities(G):
    arrival_rates = []
    capacities = []

    # æ„é€  OD æµé‡åˆ—è¡¨ï¼ˆè·¯å¾„+æµé‡ï¼‰
    OD_paths = []
    OD_flows = []

    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i == j:
                continue
            try:
                d = nx.shortest_path_length(G, i, j, weight='weight')
                flow = (node_weights[i] * node_weights[j]) ** 1.5/ (d ** 0.5)
                path = nx.shortest_path(G, i, j, weight='weight')
                OD_paths.append(path)
                OD_flows.append(flow)
            except:
                continue

    # å¯¹æ¯ä¸ªèŠ‚ç‚¹ï¼Œç»Ÿè®¡å…¶åˆ°è¾¾ç‡
    for i in range(NUM_NODES):
        Î»_i = sum(flow for path, flow in zip(OD_paths, OD_flows) if i in path)* adjustment_coefficient
        arrival_rates.append(Î»_i)

        import math
        c_i = math.ceil((Î»_i * max_wait_time / 60) / service_rate)

        capacities.append(c_i)

    # æ‰“å°
    print("\nğŸ“Š å®šå®¹é˜¶æ®µç»“æœï¼ˆæ¯ä¸ªèŠ‚ç‚¹çš„åˆ°è¾¾ç‡å’Œæœ€å°æ¡©æ•°ï¼‰")
    print("èŠ‚ç‚¹ç¼–å·\tåˆ°è¾¾ç‡Î»\tæ‰€éœ€æ¡©æ•°")
    print("--------------------------------")
    for i in range(NUM_NODES):
        print(f"{i+1:<8}\t{arrival_rates[i]:.2f}\t{capacities[i]}")

    return arrival_rates, capacities


# ---------------------- ç”Ÿæˆåˆå§‹ç§ç¾¤ ----------------------
def generate_population():
    return np.random.randint(0, 2, size=(POP_SIZE, DNA_SIZE))

# ---------------------- é¢„ç®—çº¦æŸä¿®æ­£ ----------------------
def compute_cost(ind, capacities):
    total_cost = 0
    for i, x in enumerate(ind):
        if x == 1:
            total_cost += fixed_cost + capacities[i] * variable_cost
    return total_cost
#-------------éšæœºå°†ä¸ç¬¦åˆé¢„ç®—çº¦æŸçš„æ–¹æ¡ˆä¸­éšæœºåŸºå› ä½ç‚¹æ”¹æˆ0-------------
def repair_individual(ind,capacities):
    while compute_cost(ind,capacities) > budget:
        ones = np.where(ind == 1)[0]
        if len(ones) == 0:
            break
        i = random.choice(ones)
        ind[i] = 0
    return ind
#-------------è·¯å¾„å¯è¡Œæ€§çº¦æŸï¼ˆä¸åˆ°è¾¾æ¯ç‚¹çš„å‰©ä½™ç”µé‡æœ‰å…³ï¼‰-------------
def is_path_feasible(start, end, ind, G):
    try:
        path = nx.dijkstra_path(G, start, end, weight='weight')
        battery = battery_range if ind[start] else battery_range / 2
        for k in range(len(path) - 1):
            d = G[path[k]][path[k + 1]]['weight']
            battery -= d
            if battery < 0:
                return False
            if ind[path[k + 1]]:
                battery = battery_range
        return battery >= battery_range / 2 if not ind[end] else True
    except:
        return False
#-------------åªæœ‰å½“è·¯å¾„å¯è¡Œæ—¶æ‰€æˆªå–çš„æµé‡æ‰è®¡å…¥æ€»æµé‡-------------
def evaluate_fitness(ind, G):
    total_flow = 0
    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i == j:
                continue
            try:
                d = nx.shortest_path_length(G, i, j, weight='weight')
                flow = (node_weights[i] * node_weights[j])  / (d ** 1.5)
                if is_path_feasible(i, j, ind, G):
                    total_flow += flow
            except:
                continue
    return total_flow

def calculate_total_allflow(G):
    total_allflow = 0
    for i in range(NUM_NODES):
        for j in range(NUM_NODES):
            if i != j:
                try:
                    d = nx.shortest_path_length(G, i, j, weight='weight')
                    flow = (node_weights[i] * node_weights[j]) / (d ** 1.5)
                    total_allflow += flow
                except:
                    continue
    return total_allflow

def crossover(parent, pop):
    child = parent.copy()
    if np.random.rand() < CROSS_RATE:
        i_ = np.random.randint(0, POP_SIZE)
        cross_points = np.random.randint(0, 2, DNA_SIZE).astype(bool)
        child[cross_points] = pop[i_][cross_points]
    return child

def mutate(child):
    for i in range(DNA_SIZE):
        if np.random.rand() < MUTATION_RATE:
            child[i] = 1 - child[i]
    return child

def tournament_selection(fitnesses):
    idx1, idx2 = random.sample(range(len(fitnesses)), 2)
    return idx1 if fitnesses[idx1] > fitnesses[idx2] else idx2

def run_genetic_algorithm(G, capacities):
    population = np.random.randint(0, 2, size=(POP_SIZE, NUM_NODES))
    population = np.array([repair_individual(ind, capacities) for ind in population])
    fitnesses = np.array([evaluate_fitness(ind, G) for ind in population])
    best_solution = population[np.argmax(fitnesses)]
    best_fitness = max(fitnesses)

    for generation in range(N_GENERATIONS):
        new_population = []
        for _ in range(POP_SIZE):
            idx = tournament_selection(fitnesses)
            parent = population[idx]
            child = crossover(parent, population)
            child = mutate(child)
            child = repair_individual(child, capacities)
            new_population.append(child)

        population = np.array(new_population)
        fitnesses = np.array([evaluate_fitness(ind, G) for ind in population])
        current_best = population[np.argmax(fitnesses)]

        if max(fitnesses) > best_fitness:
            best_solution = current_best
            best_fitness = max(fitnesses)
        population[0] = best_solution
        fitnesses[0] = best_fitness


        # è®¡ç®—æ€»æµé‡ä¸æˆªå–å æ¯”
    total_allflow = calculate_total_allflow(G)
    percentage = 100 * best_fitness / total_allflow if total_allflow > 0 else 0


    print("\nâœ… æœ€ä¼˜é€‰å€æ–¹æ¡ˆï¼š", np.where(best_solution == 1)[0])
    print(f"æˆªå–æµé‡æ€»å’Œï¼š{best_fitness:.2f}")
    print(f"å»ºè®¾æˆæœ¬ï¼š{compute_cost(best_solution, capacities)}")
    print(f"æˆªå–å æ€»æµé‡æ¯”ä¾‹ï¼š{percentage:.2f}%")

def main():
    arrival_rates, capacities = calculate_arrival_rates_and_capacities(G)
    run_genetic_algorithm(G, capacities)

if __name__ == "__main__":
    main()
